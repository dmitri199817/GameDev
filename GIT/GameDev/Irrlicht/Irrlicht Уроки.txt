	Уроки Irrlicht
================================================

1) ЗАГРУЗКА МИРА

#include <irrlicht.h>
 using namespace irr;

 int main()
 {
        // start up the engine
        IrrlichtDevice *device = createDevice(video::EDT_OPENGL,
                core::dimension2d<u32>(640,480)); 

        video::IVideoDriver* driver = device->getVideoDriver();// получаем видеодрайвер
        scene::ISceneManager* scenemgr = device->getSceneManager();//загружаем менеджер сцены

        device->setWindowCaption(L"Hello World!");//заголовок окна

        // load and show quake2 .md2 model
        scene::ISceneNode* node = scenemgr->addAnimatedMeshSceneNode(
                scenemgr->getMesh("quake2model.md2"));

        // if everything worked, add a texture and disable lighting
        if (node)
        {
                node->setMaterialTexture(0, driver->getTexture("texture.bmp"));//загр. текстуру
                node->setMaterialFlag(video::EMF_LIGHTING, false);//загр. свет
        }

        // add a first person shooter style user controlled camera
        scenemgr->addCameraSceneNodeFPS();

        // draw everything
        while(device->run() && driver)
        {
                driver->beginScene(true, true, video::SColor(255,0,0,255));
                scenemgr->drawAll();
                driver->endScene();
        }

        // delete device
        device->drop();
        return 0;
 }

deviceType:
========================
EDT_SOFTWARE,
EDT_BURNINGSVIDEO,
EDT_NULL, EDT_DIRECT3D8,
EDT_DIRECT3D9,
EDT_OPENGL
========================



//ВАЖНО ПОЛОЖИТЬ В ПАПКУ С ПРИЛОЖ. (*.exe) ФАЙЛЫ: quake2model.md2, texture.bmp;

2) ЗАГРУЗКА КАРТЫ + ЗАГРУЗКА Mesh'a 

Перед основным циклом добавим следующие строки:

----------------------------------------Map---------------------
// add a node
	ISceneNode* node = 0;

// add .pk3 archive to the file system
        device->getFileSystem()->addZipFileArchive("quake3map.pk3");

// load .bsp file and show it using an octree
        node = scenemgr->addOctreeSceneNode(scenemgr->getMesh("quake3map.bsp"));

----------------------------------------Mesh--------------------
// load Mesh
SceneManager->addAnimatedMeshSceneNode(
                SceneManager->getMesh("yourmesh.3ds"));
----------------------------------------------------------------

device->getCursorControl()->setVisible(false);//убираем курсор


//ВАЖНО ПОЛОЖИТЬ В ПАПКУ С ПРИЛОЖ. (*.exe) ФАЙЛЫ: quake3map.pk3, quake3map.bsp, yourmesh.3ds;


================================================================
СПИСОК ПОДДЕРЖИВАЕМЫХ ДВИЖКОМ ФОРМАТОВ ФАЙЛОВ ДЛЯ ЗАГР. КАРТЫ:
 
1) 3D Studio (.3ds)
2) Bliz Basic B3D (.b3d)
3) Cartography shop 4 (.csm)
4) COLLADA (.dae, .xml)
5) Delgine DeleD (.dmf)
6) DirectX (.x)
7) Maya (.obj)
8) Milkshape (.ms3d)
9) My3D (.my3d)
10) OCT (.oct)
11) OGRE Meshes (.mesh)
12) Pulsar LMTools (.lmts)
13) Quake 3 levels (.bsp)
14) Quake 2 models (.md2)

================================================================

3) ДОБАВЛЕНИЕ ТЕКСТА НА ЭКРАН

1. IGUIEnvironment* guienv = device->getGUIEnvironment();

2. guienv->addStaticText(L"Hello World! This is the Irrlicht Software renderer!",
                rect<s32>(10,10,260,22), true);

4) КЛАВИАТУРА

1. Добавим класс ресивера

class MyEventReceiver : public IEventReceiver
{
public:
        // This is the one method that we have to implement
        virtual bool OnEvent(const SEvent& event)
        {
                // Remember whether each key is down or up
                if (event.EventType == irr::EET_KEY_INPUT_EVENT)
                        KeyIsDown[event.KeyInput.Key] = event.KeyInput.PressedDown;

                return false;
        }

        // This is used to check whether a key is being held down
        virtual bool IsKeyDown(EKEY_CODE keyCode) const
        {
                return KeyIsDown[keyCode];
        }
        
        MyEventReceiver()
        {
                for (u32 i=0; i<KEY_KEY_CODES_COUNT; ++i)
                        KeyIsDown[i] = false;
        }

private:
        // We use this array to store the current state of each key
        bool KeyIsDown[KEY_KEY_CODES_COUNT];
};

2. Добавим "MyEventReceiver receiver;" до createDevice

3. в ...createDevice( ..., &receiver);

4. в while(device->run()

{
 if(receiver.IsKeyDown(irr::KEY_KEY_W))
	{
	... какая-либо функция ...
	}
}

5) АНИМАЦИЯ НОДЫ(УЗЛА)

1. Добавим Аниматор

----------------------------КРУГ----------------------
 ISceneNodeAnimator* anim = smgr->createFlyCircleAnimator(
core::vector3df(0,0,30), 20.0f);
if (anim)
{
cube->addAnimator(anim);
anim->drop();
}
----------------------------ЛИНИЯ----------------------
ISceneNodeAnimator* anim = smgr->createFlyStraightAnimator(
core::vector3df(100,0,60), core::vector3df(-100,0,60), 3500, true,true);
if (anim)
{
anms->addAnimator(anim);
anim->drop();
}

----------------------------ВРАЩЕНИЕ----------------------
if (SkyBox) 
    {scene ::ISceneNodeAnimator * ansb2 = 
    smgr->createRotationAnimator (core::vector3df (0,0.01,0)); 
      SkyBox->addAnimator (ansb2); 
    ansb2->drop() ; 
    }
----------------------------------------------------------


2. Смена Фреймов

IAnimatedMeshSceneNode* anms = smgr->addAnimatedMeshSceneNode(
smgr->getMesh("ninja.b3d"));

anms->setMaterialFlag(video::EMF_LIGHTING, false);
anms->setFrameLoop(0, 13); // фреймы модели с 0 по 13 изображают бег
anms->setAnimationSpeed(15); //скорость проигрывания анимации
//anms->setMaterialTexture(0, driver->getTexture("sydney.bmp"));
}

3. Трансформации Ноды


anms->setScale(core::vector3df(2.f,2.f,2.f)); // маштабируем в 2 раза по XYZ осям
anms->setRotation(core::vector3df(0,-90,0)); // поворачиваем на 90 град. вокруг Y

4. Камера

ICameraSceneNode* camera = smgr->addCameraSceneNodeFPS(0,100.0f,0.1f); // 3d-камера;
// 1) родитель (обычно = 0 )
// 2) скорость поворота (100.0f)
// 3) скорость перемещения (0.1f)

	camera->setPosition(core::vector3df(0,60,-30)); //позиция камеры
	camera->setTarget(core::vector3df(0,0,30)); // куда смотреть(цель)
