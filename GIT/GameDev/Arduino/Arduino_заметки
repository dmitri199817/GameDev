	Заметки Arduino
————————————————————————————————————

1. СТРУКТУРА ПРОГРАММЫ, КОНСТАНТЫ

1) Вы должны объявить эти две основные функции. 

Функция setup() запускается один раз, после каждого включения питания или сброса платы Arduino/Freeduino. Используйте её, чтобы инициализировать переменные, установить режимы работы цифровых портов, и т.д. 

Функция loop() в бесконечном цикле последовательно раз за разом исполняет команды, которые описаны в ее теле. Т.е. после завершения функции снова произойдет ее вызов. 

2) Константы

Константы – предопределенные значения. Они используются, чтобы делать программы более легкими для чтения. 

#define HIGH 0x1 - ЕСТЬ СИГНАЛ (0B)
#define LOW  0x0 - НЕТ СИГНАЛА (5B)

3) Настройка цифровых портов на ввод (INPUT) и вывод (OUTPUT) сигналов

pinMode(13, OUTPUT);  // 13й вывод будет выходом
  pinMode(12, INPUT);


2. ЦИФРОВОЙ ВВОД/ВЫВОД


1) pinMode (порт, режим); 


Описание: 
Конфигурирует указанный порт на ввод или вывод сигнала. 

Параметры: 
порт – номер порта, режим которого Вы желает установить (значение целого типа от 0 до 13). 

режим – либо INPUT (ввод) либо OUTPUT (вывод). 

Пример: 

  pinMode(13, OUTPUT);  //13й вывод будет выходом
  pinMode(12, INPUT);   //а 12й – входом

2) digitalWrite(порт, значение); 


Описание: 
Устанавливает высокий (HIGH) или низкий (LOW) уровень напряжения на указанном порте. 

Параметры: 
порт: номер порта 

значение: HIGH или LOW 

Пример: 

digitalWrite(13, HIGH);  // выставляем 13й вывод в «высокое» состояние

3) value = digitalRead (порт); 


Описание: 
Считывает значение на указанном порту 

Параметры: 
порт: номер опрашиваемого порта 

Возвращаемое значение: возвращает текущее значение на порту (HIGH или LOW) типа int 

Пример: 

  int val;
  val = digitalRead(12);  // опрашиваем 12й вывод


Примечание: 
Если к считываемому порту ничего не подключено, то функция digitalRead () может беспорядочно возвращать значения HIGH или LOW. 


3. АНАЛОГОВЫЙ ВВОД/ВЫВОД


1) value = analogRead(порт); 


Описание: 
Считывает значение с указанного аналогового порта. Arduino/Freeduino содержит 6 каналов аналого-цифрового преобразователя на 10 битов каждый. Это означает, что входное напряжения от 0 до 5В преобразовывается в целочисленное значение от 0 до 1023. Разрешающая способность считывания составляет: 5V/1024 значений = 0,004883 В/значение (4,883 мВ). Требуется приблизительно 100 нсек (0.0001 сек), чтобы считать значение аналогового ввода, так что максимальная скорость считывания — приблизительно 10000 раз в секунду. 

Параметры: 
порт: номер опрашиваемого аналогового входа 

Возвращаемое значение: возвращает число типа int в диапазоне от 0 до 1023, считанное с указанного порта. 

Пример: 

  int val;
  val = analogRead(0);  // считываем значение на 0м аналоговом входе


Примечание: 
Аналоговые порты, по-умолчанию, определенны на ввод сигнала и в отличие от цифровых портов их не требуется конфигурировать с помощью вызова функции pinMode. 

2) analogWrite(порт, значение); 


Описание: 
Выводит на порт аналоговое значение. Эта функция работает на: 3, 5, 6, 9, 10, и 11 цифровых портах Arduino/Freeduino/CraftDuino. На старых версиях плат Arduino на основе микроконтроллера ATmega8 функция analogWrite() работает только на портах 9, 10 и 11.

Может применяться для изменения яркости светодиода, для управления двигателем и т.д. После вызова функции analogWrite, соответствующий порт начинает работать в режиме ШИМ (Широтно-Импульсная Модуляция) напряжения до тех пор, пока не будет следующего вызова функции analogWrite (или функций digitalRead / digitalWrite на том же самом порте). 

Параметры: 
порт: номер опрашиваемого аналогового входа 

значение: целочисленное между 0 и 255. Значение 0 генерирует 0 В на указанном порте; значение 255 генерирует +5В на указанном порте. Для значений между 0 и 255, порт начинает быстро чередовать уровень напряжения 0 и +5 В — чем выше значение, тем, более часто порт генерирует уровень HIGH (5 В). 

Пример: 

  analogWrite(9, 128);  // устанавливаем на 9 контакте значение эквивалентное 2,5В


Примечание: 
Нет необходимости вызвать функцию pinMode, чтобы установить порт на вывод сигналов перед вызовом функции analogWrite. 

Частота генерирования сигнала – приблизительно 490 Гц.


4. ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ ВВОДА/ВЫВОДА


1) tone(порт, частота, длительность);

Описание:
Генерирует на выходе порта сигнал — прямоугольную «волну», заданной частоты (в Герцах) и с 50% рабочим циклом. Длительность сигнала можно задать параметром (в милисекундах), иначе сигнал будет генеририровать до тех пор, пока не будет вызвана функция noTone(). Для воспроизведения сигнала, к порту может быть подключен пьезоизлучатель или динамик.

Параметры: 
порт: номер порта ввода-выхода, на котором будет генерироваться сигнал
частота: частота сигнала в Герцах
длительность: длительность сигнала в миллисекундах

Пример:
tone(12, 2400); // выдаём на 12 пине сигнал с частотой 2400 Гц


Примечание: 
Одновременно может воспроизводиться только один сигнал. Если на одном порту, сигнал уже воспроизводится, то новый вызов tone() на другом порту ничего не даст, но если вызвать tone() на том же порту, то будет установлена новая частота сигнала.
Использование функции tone() помешает использовать ШИМ на портах 3 и 11 (кроме платы Arduino Mega).

2) noTone(порт);


Описание:
Останавливает сигнал, генерируемый на порту вызовом функции tone(). Если сигнал не генерировался, то вызов noTone() ничего не даст.

Параметры: 
порт: номер порта, на котором генерируется сигнал

Пример:
noTone(12); // останавливаем генерацию сигнала на 12 пине


Примечание:
Если необходимо генерировать сигналы на разных портах, то сначала следует остановить один сигнал функцией noTone(), а затем запускать генерацию нового сигнала на другом порту функцией tone().

3) pulseIn(порт, значение, таймаут); 


Описание: 
Считывает импульс (высокий или низкий) c цифрового порта и возвращает продолжительность импульса в микросекундах, импульс ожидается в течении таймаута(если не указать — будет ждать 1с)

Например, если параметр «значение» при вызове функции установлен в HIGH, то pulseIn() ожидает, когда на порт поступит высокий уровень сигнала. С момента его поступления начинается отсчет времени до тех пор, пока на порт не поступит низкий уровень сигнала. Функция возвращает длину импульса (высокого уровня) в микросекундах. Работает с импульсами от 10 микросекунд до 3 минут. Обратите внимание, что эта функция не будет возвращать результат, пока импульс не будет обнаружен или пока не истечёт таймаут (по умолчанию 1с) 

Параметры: 
порт: номер порта, с которого считываем импульс 

значение: тип импульса HIGH или LOW 

таймаут: время в микросекундах в течении которого ждать импульс, опция, по умолчанию 1с

Возвращаемое значение: возвращает длительность импульса в микросекундах (тип int) 

Пример: 

  int duration; // объявление переменной duration типа int
  duration = pulseIn(pin, HIGH); // измеряем длительность импульса


5. РАБОТА СО ВРЕМЕНЕМ


1) time = millis(); 


Описание: 
Возвращает число миллисекунд, с момента исполнения Arduino текущей программы. 
Учитывая, что значение хранится в unsigned long, что соотвествует 4 байтам и следовательно может хранить значения от 0 до 4294967295. Т.о счетчик переполнится и обнулится приблизительно через 1193 часов или же 50 дней (49.7). 

Возвращаемое значение: 
возвращает значение типа unsigned long 

Пример: 

  unsigned long time; // объявление переменной time типа unsigned long
  time = millis();    // передача количества миллисекунд

2) delay(время_мс); 


Описание: 
Приостанавливает программу на заданное число миллисекунд. 

Параметры: 
время_мс – время задержки программы в миллисекундах 

Пример: 

  delay(1000);  //пауза 1 секунда

3) delayMicroseconds(время_мкс); 


Описание: 
Приостанавливает программу на заданное число микросекунд. 

Параметры: 
время_мкс – время задержки программы в микросекундах 

Пример: 

  delayMicroseconds(500);  //пауза 500 микросекунд


6. МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

6.1 Математика 

1) min(x, y)

Описание: 
Возвращает меньшее из двух чисел

Код:
#define min(a,b) ((a)<(b)?(a):(b))


Параметры: 
x: первое число
y: второе число

Возвращаемое значение: 
Меньшее число из двух

Пример: 
sensVal = min(sensVal, 100); // sensVal не меняет значения, если он меньше 100
                                   // получается, что sensVal не сможет превысить 100.

Примечание:
т.к. min(x, y) – это макрос – не стоит использовать функции внутри скобок, чтобы избежать неправильных результатов

Например:
min(a++, 100);   // возможен неправильный результат


лучше так:
a++;
min(a, 100);

2) max(x, y)

Описание: 
Возвращает большее из двух чисел

Код:
#define max(a,b) ((a)>(b)?(a):(b))


Параметры: 
x: первое число
y: второе число

Возвращаемое значение: 
Большее число из двух

Пример: 
sensVal = max(sensVal, 20); // sensVal не меняет значения, если он больше 20
                                  // получается, что sensVal не сможет быть меньше 20.


Примечание:
т.к. max(x, y) – это макрос – не стоит использовать функции внутри скобок, чтобы избежать неправильных результатов

Например:
max(a--, 0);   // возможен неправильный результат


лучше так:
a--;
max(a, 0); 

3) abs(x)

Описание: 
Возвращает модуль (абсолютную величину) числа. 

Код:
#define abs(x) ((x)>0?(x):-(x))


Параметры: 
x: число

Возвращаемое значение: 
x: если x больше или равен 0. 
-x: если x меньше 0.

Примечание:
т.к. abs(x) – это макрос – не стоит использовать функции внутри скобок, чтобы избежать неправильных результатов

Например:
abs(a++);   // возможен неправильный результат


лучше так:
a++;
abs(a);  


4) constrain(x, a, b)

Описание: 
Проверяет находится ли число x в диапазоне (a,b)

Код:
#define constrain(amt,low,high) ((amt)<(low)?(low):((amt)>(high)?(high):(amt)))


Параметры: 
x: число для проверки
a: нижняя грань диапазона
b: верхняя грань диапазона

Возвращаемое значение: 
x: если x лежит между a и b 
a: если x меньше, чем a 
b: если x больше, чем b

Пример: 
sensVal = constrain(sensVal, 10, 150); // ограничиваем интервал значений сенсора между 10 и 150


5) map(value, fromLow, fromHigh, toLow, toHigh)

Описание: 
Отображает число из одного диапазона в другой. 

Код: 

long map(long x, long in_min, long in_max, long out_min, long out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}


Примечание:
Функция не проверяет – содержится ли число в необходимом диапазоне, поэтому можно вызвать функцию constrain() перед или после функции map().
Так же, «нижняя граница » диапазонов может быть больше или меньше, чем «верхняя граница», т.о. функция map() может быть использована, чтобы перевернуть диапазон чисел, например:
y = map(x, 1, 50, 50, 1); 


функция так же может оперировать с отрицательными числами:
y = map(x, 1, 50, 50, -100); 


Функция map() оперирует целыми числами, поэтому никаких десятичных значений не выдаётся. Дробные остатки отсекаются, а не округляются или усредняются.

Параметры: 
value: число для отображения
fromLow: нижняя граница текущего диапазона числа value
fromHigh: верхняя граница текущего диапазона числа value
toLow: нижняя граница целевого диапазона
toHigh: верхняя граница целевого диапазона

Возвращаемое значение: 
Целое число типа long

Пример: 

/* отображает аналоговое значение к 8 битам (диапазон от 0 до 255) */
  int val = analogRead(0);
  val = map(val, 0, 1023, 0, 255);
  analogWrite(9, val);


6) pow(base, exponent)

Описание: 
Функция предназначена для возведения числа в заданную степень.

Параметры: 
base: число(float) 
exponent: степень(float)

Возвращаемое значение: 
Результат возведения в степень (double)


7) sq(x)

Описание: 
Вычисляет квадрат числа: число умноженное на себя.

Код:
#define sq(x) ((x)*(x))


Параметры: 
x: число

Возвращаемое значение: 
Квадрат числа 

8) sqrt(x)

Описание: 
Вычисляет квадратный корень числа.

Параметры: 
x: число

Возвращаемое значение: 
Квадратный корень числа, тип double

6.2 Тригонометрия

1) sin(rad)

Описание: 
Вычисляет синус угла (в радианах). Результат будет между -1 и 1.

Параметры: 
rad: угол в радианах (float) 

Возвращаемое значение: 
Синус угла, тип double

Примечание:
Serial.print() и Serial.println() в версиях IDE до 0018 не поддерживали печати типа float.

2) cos(rad)

Описание: 
Вычисляет косинус угла (в радианах). Результат будет между -1 и 1.

Параметры: 
rad: угол в радианах (float) 

Возвращаемое значение: 
Косинус угла, тип double

Примечание:
Serial.print() и Serial.println() в версиях IDE до 0018 не поддерживали печати типа float.

3) tan(rad)

Описание: 
Вычисляет тангенс угла (в радианах). Результат будет между плюс и минус бесконечностью :)

Параметры: 
rad: угол в радианах (float) 

Возвращаемое значение: 
Тангенсс угла, тип double

Примечание:
Serial.print() и Serial.println() в версиях IDE до 0018 не поддерживали печати типа float.


7. ПСЕВДОСЛУЧАЙНЫЕ ЧИСЛА

1) void randomSeed(unsigned int seed)

Описание: 
randomSeed () инициализирует генератор псевдослучайных чисел, в результате чего генерация начинается с произвольного числа псевдослучайной последовательности.

Если важно, чтобы последовательность значений сгенерированной функцией random() отличались друг от друга при разных запусках скетча – можно вызывать randomSeed () для инициализации генератора псевдослучайных чисел с параметром, считываемым с помощью analogRead () из незадействованного порта. 

Наоборот, иногда может быть полезно использовать псевдослучайную последовательность, которые точно повторяются. Это можно сделать, вызывая randomSeed () с фиксированным числом.

Параметры: 
unsigned int seed – число для инициализации генератора псевдослучайных чисел

Пример: 
long randNumber;

void setup(){
  Serial.begin(9600);
  randomSeed(analogRead(0));
}

void loop(){
  randNumber = random(300);
  Serial.println(randNumber);
  delay(50);
}

2) 
long random(long howbig)
long random(long howsmall, long howbig)

Описание: 
Генерирует псевдослучайное число

Параметры: 
min – нижняя граница случайных чисел, (включая)
max — верхняя граница случайных чисел, (не включая)

Возвращаемое значение: 
случайное число(тип long) между min и max–1

Пример: 

long randNumber;

void setup(){
  Serial.begin(9600);

  // если аналоговый порт 0 не подключён, случайный аналоговый
  // шум будет заставлять randomSeed() генерировать
  // разные псевдослучайные числа при каждом запуске скетча
  randomSeed(analogRead(0));
}

void loop() {
  // печать случайного числа от 0 до 299
  randNumber = random(300);
  Serial.println(randNumber);  

  // печать случайного чмсла от 10 до 19
  randNumber = random(10, 20);
  Serial.println(randNumber);

  delay(50);
}


8. ПОСЛЕДОВАТЕЛЬНАЯ ПЕРЕДАЧА ДАННЫХ


1) Serial.begin(long);

Вызов: 
Serial.begin(скорость_передачи); 


Описание: 
Устанавливает скорость передачи информации COM порта битах в секунду для последовательной передачи данных. Для того чтобы поддерживать связь с компьютером, используйте одну из этих нормированных скоростей: 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, или 115200. Также Вы можете определить другие скорости при связи с другим микроконтроллером по портам 0 и 1. 

Параметры: 
скорость_передачи: скорость потока данных в битах в секунду. 

Пример: 
Serial.begin(9600); //устанавливаем скорость 9600 бит/сек

2) Serial.available(void);

Вызов: 
count = Serial.available(); 


Описание: 
Принимаемые по последовательному порту байты попадают в буфер микроконтроллера, откуда Ваша программа может их считать. Функция возвращает количество накопленных в буфере байт. Последовательный буфер может хранить до 128 байт. 

Возвращаемое значение: 
Возвращает значение типа uint8_t (typedef uint8_t byte;) – количество байт, доступных для чтения, в последовательном буфере, или 0, если ничего не доступно. 

Пример: 
if (Serial.available() > 0) { // Если в буфере есть данные
    // здесь должен быть прием и обработка данных
  }


3) Serial.read(void);

Вызов: 
char = Serial.read(); 


Описание: 
Считывает следующий байт из буфера последовательного порта. 

Возвращаемое значение: 
Первый доступный байт входящих данных с последовательного порта, или -1 если нет входящих данных. 

Пример: 
incomingByte = Serial.read(); // читаем байт

4) Serial.write(uint8_t c)

Вызов: 
Serial.write(val);
Serial.write(str);
Serial.write(buf, len);


Описание: 
Записывает данные в последовательный порт. Данные посылаются как байт или последовательность байт; для отправки символьной информации следует использовать функцию print().

Параметры: 
val: переменная для передачи, как единственный байт
str: строка для передачи, как последовательность байт
buf: массив для передачи, как последовательность байт
len: длина массива

5) Serial.flush(void)

Вызов: 
Serial.flush(); 

Описание: 
Очищает входной буфер последовательного порта. Находящиеся в буфере данные теряются, и дальнейшие вызовы Serial.read() или Serial.available() будут иметь смысл для данных, полученных после вызова Serial.flush(). 

Пример: 
Serial.flush(); // Очищаем буфер – начинаем прием данных «с чистого листа»


6) Serial.print()

Функции print наследуются классом HardwareSerial от класса Print (\hardware\cores\arduino\ Print.h)

Описание: 
Вывод данных на последовательный порт. 

Параметры: 
Функция имеет несколько форм вызова в зависимости от типа и формата выводимых данных.
Примеры:

Serial.print(b, DEC); выводит ASCII-строку — десятичное представление числа b. 

int b = 79;
Serial.print(b, DEC); //выдаст в порт строку «79»

Serial.print(b, HEX) выводит ASCII-строку — шестнадцатиричное представление числа b. 

int b = 79;
Serial.print(b, HEX); //выдаст в порт строку «4F»


Serial.print(b, OCT) выводит ASCII-строку — восьмеричное представление числа b. 

int b = 79;
Serial.print(b, OCT); //выдаст в порт строку «117»


Serial.print(b, BIN) выводит ASCII-строку — двоичное представление числа b. 

int b = 79;
Serial.print(b, BIN); //выдаст в порт строку «1001111»


Serial.print(b, BYTE) выводит младший байт числа b. 

int b = 79;
Serial.print(b, BYTE); //выведет число 79 (один байт). В мониторе
//последовательного порта получим символ «O» - его
//код равен 79


Serial.print(str) если str – строка или массив символов, побайтно передает str на COM-порт. 

char bytes[3] = {79, 80, 81};    //массив из 5 байт со значениями 79,80,81
Serial.print("Here our bytes:"); //выводит строку «Here our bytes:»
Serial.print(bytes);             //выводит 3 символа с кодами 79,80,81 – 
                                 //это символы «OPQ»


Serial.print(b) если b имеет тип byte или char, выводит в порт само число b. 

char b = 79;
Serial.print(b); //выдаст в порт символ «O»


Serial.print(b) если b имеет целый тип, выводит в порт десятичное представление числа b. 

int b = 79;
Serial.print(b); //выдаст в порт строку «79»


7) Serial.println()

Описание: 
Функция Serial.println аналогична функции Serial.print, и имеет такие же варианты вызова. Единственное отличие заключается в том, что после данных дополнительно выводятся два символа – символ возврата каретки (ASCII 13, или '\r') и символ новой линии (ASCII 10, или '\n'). 
Как нетрудно догадаться, это реализовано простым добавлением вызова функции:

void Print::println(void)
{
  print('\r');
  print('\n');  
}

Например, функция вывода символа:

void Print::println(char c)
{
  print( c );
  println();  
}


Пример 1 и пример 2 выведут в порт одно и то же: 

Пример 1: 

  int b = 79;
  Serial.print(b, DEC); //выдаст в порт строку «79»
  Serial.print("\r\n"); //выведет символы "\r\n" – перевод строки
  Serial.print(b, HEX); //выдаст в порт строку «4F»
  Serial.print("\r\n"); //выведет символы "\r\n" – перевод строки


Пример 2: 

  int b = 79;
  Serial.println(b, DEC); //выдаст в порт строку «79\r\n»
  Serial.println(b, HEX); //выдаст в порт строку «4F\r\n»


В мониторе последовательного порта получим: 


79
4F


9. ПРЕРЫВАНИЯ

Прерывание (англ. interrupt) — сигнал, сообщающий процессору о наступлении какого-либо события. При этом выполнение текущей последовательности команд приостанавливается, и управление передаётся обработчику прерывания, который выполняет работу по обработке события и возвращает управление в прерванный код.

1) void attachInterrupt(uint8_t, void (*)(void), int mode);

Описание: 
Определяет, какую функцию вызывать, когда происходит внешнее прерывание.
Замещает предыдущую функцию, если таковая была привязана к данному прерыванию.
Большинство плат Arduino/Freeduino имеют два внешних прерывания с номерами 0 (на digital pin 2) и 1 (на digital pin 3). Arduino Mega имеет дополнительно ещё четыре:
с номерами 2 (pin 21), 3 (pin 20), 4 (pin 19) и 5 (pin 18).

Вызов:
attachInterrupt(interrupt, function, mode);


Параметры: 
interrupt: номер прерывания (int) 

function: функция, которая должны вызываться при прерывании. Функция не должна принимать параметров и не должна ничего возвращать.

mode: определяет, когда должно сработать прерывание. Определены следующие константы:
LOW — вызов прерывания всякий раз, когда на порту низкий уровень напряжения;
CHANGE – прерывание вызывается при изменении значения на входе;
RISING – вызов прерывания при изменении уровня напряжения с низкого (LOW) на высокое(HIGH)
FALLING – вызов прерывания при изменении уровня напряжения с высокого (HIGH) на низкое (LOW)

Возвращаемое значение: 
ничего

Пример:
//
// светодиод, подключённый к digital pin 13 будет изменять своё 
// состояние при изменении напряжения на digital pin 2
//
int pin = 13;
volatile int state = LOW;

void setup()
{
  pinMode(pin, OUTPUT);              // порт как выход
  attachInterrupt(0, blink, CHANGE); // привязываем 0-е прерывание к функции blink().
}

void loop()
{
  digitalWrite(pin, state);          // выводим state  
}

void blink()
{
  state = !state;                    // меняем значение на противоположное
}


Примечание относительно использования volatile:
Описатель volatile используется в описании переменных и информирует компилятор, что значение данной переменной может быть изменено способом, который компилятор не в состоянии отследить. Для переменных, объявленных volatile, компилятор не должен применять средства оптимизации, изменяющие положение переменной в памяти (например, помещающие её в регистр) или полагающиеся на неизменность значения переменной в промежутке между двумя присваиваниями ей значения.
указывая volatile при объявлении переменной, программист просит компилятор не оптимизировать эту переменную.

Т.о. переменная получается как бы «расшарена». Т.е. значение переменной могут изменять разные части программы — обработчики прерываний, подпрограммы, функции.

2) void detachInterrupt(uint8_t);

Описание: 
Отключает указанное прерывание.

Вызов:
detachInterrupt(interrupt);


Параметры: 
interrupt: номер прерывания для отключения (0 или 1).

Возвращаемое значение: 
ничего

10. ПРЕРЫВАНИЯ

Прерывание (англ. interrupt) — сигнал, сообщающий процессору о наступлении какого-либо события. При этом выполнение текущей последовательности команд приостанавливается, и управление передаётся обработчику прерывания, который выполняет работу по обработке события и возвращает управление в прерванный код.

1) void attachInterrupt(uint8_t, void (*)(void), int mode);

Описание: 
Определяет, какую функцию вызывать, когда происходит внешнее прерывание.
Замещает предыдущую функцию, если таковая была привязана к данному прерыванию.
Большинство плат Arduino/Freeduino имеют два внешних прерывания с номерами 0 (на digital pin 2) и 1 (на digital pin 3). Arduino Mega имеет дополнительно ещё четыре:
с номерами 2 (pin 21), 3 (pin 20), 4 (pin 19) и 5 (pin 18).

Вызов:
attachInterrupt(interrupt, function, mode);


Параметры: 
interrupt: номер прерывания (int) 

function: функция, которая должны вызываться при прерывании. Функция не должна принимать параметров и не должна ничего возвращать.

mode: определяет, когда должно сработать прерывание. Определены следующие константы:
LOW — вызов прерывания всякий раз, когда на порту низкий уровень напряжения;
CHANGE – прерывание вызывается при изменении значения на входе;
RISING – вызов прерывания при изменении уровня напряжения с низкого (LOW) на высокое(HIGH)
FALLING – вызов прерывания при изменении уровня напряжения с высокого (HIGH) на низкое (LOW)

Возвращаемое значение: 
ничего

Пример:
//
// светодиод, подключённый к digital pin 13 будет изменять своё 
// состояние при изменении напряжения на digital pin 2
//
int pin = 13;
volatile int state = LOW;

void setup()
{
  pinMode(pin, OUTPUT);              // порт как выход
  attachInterrupt(0, blink, CHANGE); // привязываем 0-е прерывание к функции blink().
}

void loop()
{
  digitalWrite(pin, state);          // выводим state  
}

void blink()
{
  state = !state;                    // меняем значение на противоположное
}


Примечание относительно использования volatile:
Описатель volatile используется в описании переменных и информирует компилятор, что значение данной переменной может быть изменено способом, который компилятор не в состоянии отследить. Для переменных, объявленных volatile, компилятор не должен применять средства оптимизации, изменяющие положение переменной в памяти (например, помещающие её в регистр) или полагающиеся на неизменность значения переменной в промежутке между двумя присваиваниями ей значения.


2) void detachInterrupt(uint8_t);

Описание: 
Отключает указанное прерывание.

Вызов:
detachInterrupt(interrupt);


Параметры: 
interrupt: номер прерывания для отключения (0 или 1).

Возвращаемое значение: 
ничего

11. EEPROM

EEPROM — (Electrically Erasable Programmable Read-Only Memory) электрически стираемое перепрограммируемое ПЗУ, ЭСППЗУ). Память такого типа может стираться и заполняться данными несколько десятков тысяч раз. Используется в твердотельных накопителях. Одной из разновидностей EEPROM является флеш-память (Flash Memory).



